\hypertarget{stack_8c}{}\doxysection{/mnt/c/\+Users/zenj2/\+L\+I\+R\+S-\/cache/source/stack.c File Reference}
\label{stack_8c}\index{/mnt/c/Users/zenj2/LIRS-\/cache/source/stack.c@{/mnt/c/Users/zenj2/LIRS-\/cache/source/stack.c}}


File with the implementation of functions from the header file and static functions for the stack object.  


{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include $<$assert.\+h$>$}\newline
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include \char`\"{}all\+\_\+objects.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}hash.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}list.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}stack.\+h\char`\"{}}\newline
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static void \mbox{\hyperlink{stack_8c_a5225b84245d2bb229e73dda3f07e0e2a}{to\+\_\+non\+\_\+resident}} (int name, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}})
\item 
static void \mbox{\hyperlink{stack_8c_a90e2065c230213850e1efca2c8e0eb35}{free\+\_\+element\+\_\+stack}} (struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$\mbox{\hyperlink{structelement}{element}})
\item 
static char \mbox{\hyperlink{stack_8c_a2bda9b516c37d9673a74cf6c55736ecb}{element\+\_\+is\+\_\+\+L\+IR}} (struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$down\+\_\+element)
\item 
static void \mbox{\hyperlink{stack_8c_a382b457a0bdb85f1179c5ab3874f08f7}{move\+\_\+up\+\_\+stack}} (struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$lift\+\_\+element)
\item 
static void \mbox{\hyperlink{stack_8c_afe2bc06c177d97f9c9cba1e0be0f7080}{only\+\_\+in\+\_\+list}} (int name, struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structlist}{list}} \mbox{\hyperlink{structlist}{list}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}})
\item 
static void $\ast$ \mbox{\hyperlink{stack_8c_a75ef80ffb172a42563dd712be4b408b4}{first\+\_\+entry\+\_\+in\+\_\+full}} (int name, struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structlist}{list}} \mbox{\hyperlink{structlist}{list}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}})
\item 
static struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$ \mbox{\hyperlink{stack_8c_aae41b678707d7a7ae0e85810723cd196}{clear\+\_\+stack\+\_\+to\+\_\+\+L\+IR}} (struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$down\+\_\+element, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}})
\item 
static void $\ast$ \mbox{\hyperlink{stack_8c_a4636d873697b1f557367cc40419b7747}{non\+\_\+resident\+\_\+in\+\_\+stack}} (struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structlist}{list}} \mbox{\hyperlink{structlist}{list}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}}, struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$element\+\_\+in\+\_\+stack)
\item 
static void $\ast$ \mbox{\hyperlink{stack_8c_a93facf9699e2c2f115bf2648e75f0d49}{in\+\_\+stack}} (int name, struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structlist}{list}} \mbox{\hyperlink{structlist}{list}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}}, struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$element\+\_\+in\+\_\+stack)
\item 
static void \mbox{\hyperlink{stack_8c_a6d9629de3eb7834af77047c3c184578a}{resident\+\_\+in\+\_\+stack}} (int name, struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structlist}{list}} \mbox{\hyperlink{structlist}{list}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}}, struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$element\+\_\+in\+\_\+stack)
\item 
static void $\ast$ \mbox{\hyperlink{stack_8c_a4eb2a5711ed958aee2932fddeb2738eb}{first\+\_\+entery}} (int name, int len\+\_\+\+L\+IR, struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structlist}{list}} \mbox{\hyperlink{structlist}{list}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}}, struct \mbox{\hyperlink{structcache__storage__t}{cache\+\_\+storage\+\_\+t}} $\ast$cache)
\item 
static void \mbox{\hyperlink{stack_8c_a908169c7cfd3099f33c2db71daeb4c91}{first\+\_\+filling}} (int name, int len\+\_\+\+L\+IR, struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structlist}{list}} \mbox{\hyperlink{structlist}{list}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}}, struct \mbox{\hyperlink{structcache__storage__t}{cache\+\_\+storage\+\_\+t}} $\ast$cache)
\item 
static void $\ast$ \mbox{\hyperlink{stack_8c_a68f60a10327b5f24a24ced2ebf539a11}{not\+\_\+in\+\_\+stack}} (int name, int len\+\_\+\+L\+IR, struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structlist}{list}} \mbox{\hyperlink{structlist}{list}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}}, struct \mbox{\hyperlink{structcache__storage__t}{cache\+\_\+storage\+\_\+t}} $\ast$cache)
\item 
static struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$ \mbox{\hyperlink{stack_8c_a400c152467126af53c8f0634a5161b27}{new\+\_\+upper\+\_\+element}} (int name, enum \mbox{\hyperlink{all__objects_8h_adc6e5733fc3c22f0a7b2914188c49c90}{state}} state\+\_\+element, void $\ast$location\+\_\+in\+\_\+cache, struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}})
\item 
\mbox{\Hypertarget{stack_8c_aeda066737af0dbe8b5e959f6a321fba5}\label{stack_8c_aeda066737af0dbe8b5e959f6a321fba5}} 
void $\ast$ {\bfseries L\+I\+R\+S\+\_\+algorithm} (int name, int len\+\_\+\+L\+IR, struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structlist}{list}} \mbox{\hyperlink{structlist}{list}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}}, struct \mbox{\hyperlink{structcache__storage__t}{cache\+\_\+storage\+\_\+t}} $\ast$cache)
\item 
\mbox{\Hypertarget{stack_8c_a93facf9699e2c2f115bf2648e75f0d49}\label{stack_8c_a93facf9699e2c2f115bf2648e75f0d49}} 
static void $\ast$ {\bfseries in\+\_\+stack} (int name, struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structlist}{list}} \mbox{\hyperlink{structlist}{list}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}}, struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$element\+\_\+in\+\_\+stack)
\item 
\mbox{\Hypertarget{stack_8c_a68f60a10327b5f24a24ced2ebf539a11}\label{stack_8c_a68f60a10327b5f24a24ced2ebf539a11}} 
static void $\ast$ {\bfseries not\+\_\+in\+\_\+stack} (int name, int len\+\_\+\+L\+IR, struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structlist}{list}} \mbox{\hyperlink{structlist}{list}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}}, struct \mbox{\hyperlink{structcache__storage__t}{cache\+\_\+storage\+\_\+t}} $\ast$cache)
\item 
\mbox{\Hypertarget{stack_8c_a4eb2a5711ed958aee2932fddeb2738eb}\label{stack_8c_a4eb2a5711ed958aee2932fddeb2738eb}} 
static void $\ast$ {\bfseries first\+\_\+entery} (int name, int len\+\_\+\+L\+IR, struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structlist}{list}} \mbox{\hyperlink{structlist}{list}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}}, struct \mbox{\hyperlink{structcache__storage__t}{cache\+\_\+storage\+\_\+t}} $\ast$cache)
\item 
\mbox{\Hypertarget{stack_8c_a908169c7cfd3099f33c2db71daeb4c91}\label{stack_8c_a908169c7cfd3099f33c2db71daeb4c91}} 
static void {\bfseries first\+\_\+filling} (int name, int len\+\_\+\+L\+IR, struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structlist}{list}} \mbox{\hyperlink{structlist}{list}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}}, struct \mbox{\hyperlink{structcache__storage__t}{cache\+\_\+storage\+\_\+t}} $\ast$cache)
\item 
\mbox{\Hypertarget{stack_8c_a75ef80ffb172a42563dd712be4b408b4}\label{stack_8c_a75ef80ffb172a42563dd712be4b408b4}} 
static void $\ast$ {\bfseries first\+\_\+entry\+\_\+in\+\_\+full} (int name, struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structlist}{list}} \mbox{\hyperlink{structlist}{list}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}})
\item 
\mbox{\Hypertarget{stack_8c_afe2bc06c177d97f9c9cba1e0be0f7080}\label{stack_8c_afe2bc06c177d97f9c9cba1e0be0f7080}} 
static void {\bfseries only\+\_\+in\+\_\+list} (int name, struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structlist}{list}} \mbox{\hyperlink{structlist}{list}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}})
\item 
\mbox{\Hypertarget{stack_8c_a6d9629de3eb7834af77047c3c184578a}\label{stack_8c_a6d9629de3eb7834af77047c3c184578a}} 
static void {\bfseries resident\+\_\+in\+\_\+stack} (int name, struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structlist}{list}} \mbox{\hyperlink{structlist}{list}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}}, struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$element\+\_\+in\+\_\+stack)
\item 
\mbox{\Hypertarget{stack_8c_a4636d873697b1f557367cc40419b7747}\label{stack_8c_a4636d873697b1f557367cc40419b7747}} 
static void $\ast$ {\bfseries non\+\_\+resident\+\_\+in\+\_\+stack} (struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structlist}{list}} \mbox{\hyperlink{structlist}{list}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}}, struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$element\+\_\+in\+\_\+stack)
\item 
\mbox{\Hypertarget{stack_8c_a400c152467126af53c8f0634a5161b27}\label{stack_8c_a400c152467126af53c8f0634a5161b27}} 
static struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$ {\bfseries new\+\_\+upper\+\_\+element} (int name, enum \mbox{\hyperlink{all__objects_8h_adc6e5733fc3c22f0a7b2914188c49c90}{state}} state\+\_\+element, void $\ast$location\+\_\+in\+\_\+cache, struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structhash}{hash}} $\ast$\mbox{\hyperlink{structhash}{hash}})
\item 
\mbox{\Hypertarget{stack_8c_a382b457a0bdb85f1179c5ab3874f08f7}\label{stack_8c_a382b457a0bdb85f1179c5ab3874f08f7}} 
static void {\bfseries move\+\_\+up\+\_\+stack} (struct \mbox{\hyperlink{structstack}{stack}} \mbox{\hyperlink{structstack}{stack}}, struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$lift\+\_\+element)
\item 
void \mbox{\hyperlink{stack_8c_a05e1a123d3dfcc32ce77fbe3021e4882}{print\+\_\+down}} (struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$upper\+\_\+element)
\item 
void \mbox{\hyperlink{stack_8c_abd4c5c60fc300702dbc2da5acb6078ba}{print\+\_\+up}} (struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$down\+\_\+element)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
File with the implementation of functions from the header file and static functions for the stack object. 



\doxysubsection{Function Documentation}
\mbox{\Hypertarget{stack_8c_aae41b678707d7a7ae0e85810723cd196}\label{stack_8c_aae41b678707d7a7ae0e85810723cd196}} 
\index{stack.c@{stack.c}!clear\_stack\_to\_LIR@{clear\_stack\_to\_LIR}}
\index{clear\_stack\_to\_LIR@{clear\_stack\_to\_LIR}!stack.c@{stack.c}}
\doxysubsubsection{\texorpdfstring{clear\_stack\_to\_LIR()}{clear\_stack\_to\_LIR()}}
{\footnotesize\ttfamily static struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$ clear\+\_\+stack\+\_\+to\+\_\+\+L\+IR (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$}]{down\+\_\+element,  }\item[{struct \mbox{\hyperlink{structhash}{hash}} $\ast$}]{hash }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Implements the entire algorithm for writing elements to various program objects and clearing objects if necessary. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em down\+\_\+element} & Pointer to the down element of the stack. \\
\hline
\mbox{\texttt{ in,out}}  & {\em hash} & The hash table in which changes will occur. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the new down element in stack. 
\end{DoxyReturn}
\mbox{\Hypertarget{stack_8c_a2bda9b516c37d9673a74cf6c55736ecb}\label{stack_8c_a2bda9b516c37d9673a74cf6c55736ecb}} 
\index{stack.c@{stack.c}!element\_is\_LIR@{element\_is\_LIR}}
\index{element\_is\_LIR@{element\_is\_LIR}!stack.c@{stack.c}}
\doxysubsubsection{\texorpdfstring{element\_is\_LIR()}{element\_is\_LIR()}}
{\footnotesize\ttfamily static char element\+\_\+is\+\_\+\+L\+IR (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$}]{down\+\_\+element }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Checks if the specified element has L\+IR status. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em down\+\_\+element} & Pointer to the down element of a doubly linked list. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if the element does not have the L\+IR status. 

1 if the have the L\+IR status. 
\end{DoxyReturn}
\mbox{\Hypertarget{stack_8c_a4eb2a5711ed958aee2932fddeb2738eb}\label{stack_8c_a4eb2a5711ed958aee2932fddeb2738eb}} 
\index{stack.c@{stack.c}!first\_entery@{first\_entery}}
\index{first\_entery@{first\_entery}!stack.c@{stack.c}}
\doxysubsubsection{\texorpdfstring{first\_entery()}{first\_entery()}}
{\footnotesize\ttfamily static void$\ast$ first\+\_\+entery (\begin{DoxyParamCaption}\item[{int}]{name,  }\item[{int}]{len\+\_\+\+L\+IR,  }\item[{struct \mbox{\hyperlink{structstack}{stack}}}]{stack,  }\item[{struct \mbox{\hyperlink{structlist}{list}}}]{list,  }\item[{struct \mbox{\hyperlink{structhash}{hash}} $\ast$}]{hash,  }\item[{struct \mbox{\hyperlink{structcache__storage__t}{cache\+\_\+storage\+\_\+t}} $\ast$}]{cache }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Implementation of a part of the algorithm when an element comes to the input that is not stored in cache. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & The name of the input file. \\
\hline
\mbox{\texttt{ in}}  & {\em len\+\_\+\+L\+IR} & Length of the L\+IR memory area. \\
\hline
\mbox{\texttt{ in,out}}  & {\em stack} & The stack structure in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em list} & The list structure in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em hash} & The hash table in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em cache} & The cache array where all files are stored. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Void $\ast$ pointer to the location in the cache where the incoming file should be written. 
\end{DoxyReturn}
\mbox{\Hypertarget{stack_8c_a75ef80ffb172a42563dd712be4b408b4}\label{stack_8c_a75ef80ffb172a42563dd712be4b408b4}} 
\index{stack.c@{stack.c}!first\_entry\_in\_full@{first\_entry\_in\_full}}
\index{first\_entry\_in\_full@{first\_entry\_in\_full}!stack.c@{stack.c}}
\doxysubsubsection{\texorpdfstring{first\_entry\_in\_full()}{first\_entry\_in\_full()}}
{\footnotesize\ttfamily static void$\ast$ first\+\_\+entry\+\_\+in\+\_\+full (\begin{DoxyParamCaption}\item[{int}]{name,  }\item[{struct \mbox{\hyperlink{structstack}{stack}}}]{stack,  }\item[{struct \mbox{\hyperlink{structlist}{list}}}]{list,  }\item[{struct \mbox{\hyperlink{structhash}{hash}} $\ast$}]{hash }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Implementation of a part of the algorithm when an element comes to the input that is not stored in cache and the cache is full. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & The name of the input file. \\
\hline
\mbox{\texttt{ in,out}}  & {\em stack} & The stack structure in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em list} & The list structure in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em hash} & The hash table in which changes will occur. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Void $\ast$ pointer to the location in the cache where the incoming file should be written. 
\end{DoxyReturn}
\mbox{\Hypertarget{stack_8c_a908169c7cfd3099f33c2db71daeb4c91}\label{stack_8c_a908169c7cfd3099f33c2db71daeb4c91}} 
\index{stack.c@{stack.c}!first\_filling@{first\_filling}}
\index{first\_filling@{first\_filling}!stack.c@{stack.c}}
\doxysubsubsection{\texorpdfstring{first\_filling()}{first\_filling()}}
{\footnotesize\ttfamily static void first\+\_\+filling (\begin{DoxyParamCaption}\item[{int}]{name,  }\item[{int}]{len\+\_\+\+L\+IR,  }\item[{struct \mbox{\hyperlink{structstack}{stack}}}]{stack,  }\item[{struct \mbox{\hyperlink{structlist}{list}}}]{list,  }\item[{struct \mbox{\hyperlink{structhash}{hash}} $\ast$}]{hash,  }\item[{struct \mbox{\hyperlink{structcache__storage__t}{cache\+\_\+storage\+\_\+t}} $\ast$}]{cache }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Implementation of a part of the algorithm when an element comes to the input that is not stored in cache and the cache is not yet full. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & The name of the input file. \\
\hline
\mbox{\texttt{ in}}  & {\em len\+\_\+\+L\+IR} & Length of the L\+IR memory area. \\
\hline
\mbox{\texttt{ in,out}}  & {\em stack} & The stack structure in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em list} & The list structure in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em hash} & The hash table in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em cache} & The cache array where all files are stored. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{stack_8c_a90e2065c230213850e1efca2c8e0eb35}\label{stack_8c_a90e2065c230213850e1efca2c8e0eb35}} 
\index{stack.c@{stack.c}!free\_element\_stack@{free\_element\_stack}}
\index{free\_element\_stack@{free\_element\_stack}!stack.c@{stack.c}}
\doxysubsubsection{\texorpdfstring{free\_element\_stack()}{free\_element\_stack()}}
{\footnotesize\ttfamily static void free\+\_\+element\+\_\+stack (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$}]{element }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Releases an element from stack. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em element} & Pointer to the element to be removed. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{stack_8c_a93facf9699e2c2f115bf2648e75f0d49}\label{stack_8c_a93facf9699e2c2f115bf2648e75f0d49}} 
\index{stack.c@{stack.c}!in\_stack@{in\_stack}}
\index{in\_stack@{in\_stack}!stack.c@{stack.c}}
\doxysubsubsection{\texorpdfstring{in\_stack()}{in\_stack()}}
{\footnotesize\ttfamily static void$\ast$ in\+\_\+stack (\begin{DoxyParamCaption}\item[{int}]{name,  }\item[{struct \mbox{\hyperlink{structstack}{stack}}}]{stack,  }\item[{struct \mbox{\hyperlink{structlist}{list}}}]{list,  }\item[{struct \mbox{\hyperlink{structhash}{hash}} $\ast$}]{hash,  }\item[{struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$}]{element\+\_\+in\+\_\+stack }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Implementation of a part of the algorithm when an element comes to the input that is written to the stack. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & The name of the input file. \\
\hline
\mbox{\texttt{ in,out}}  & {\em stack} & The stack structure in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em list} & The list structure in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em hash} & The hash table in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em element\+\_\+in\+\_\+stack} & Pointer to the location of the incoming element on the stack. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Void $\ast$ pointer to the location in the cache where the incoming file should be written. 
\end{DoxyReturn}
\mbox{\Hypertarget{stack_8c_a382b457a0bdb85f1179c5ab3874f08f7}\label{stack_8c_a382b457a0bdb85f1179c5ab3874f08f7}} 
\index{stack.c@{stack.c}!move\_up\_stack@{move\_up\_stack}}
\index{move\_up\_stack@{move\_up\_stack}!stack.c@{stack.c}}
\doxysubsubsection{\texorpdfstring{move\_up\_stack()}{move\_up\_stack()}}
{\footnotesize\ttfamily static void move\+\_\+up\+\_\+stack (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structstack}{stack}}}]{stack,  }\item[{struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$}]{lift\+\_\+element }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Implements the entire algorithm for writing elements to various program objects and clearing objects if necessary. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em stack} & The stack structure in which changes will occur. \\
\hline
\mbox{\texttt{ in}}  & {\em lift\+\_\+element} & Pointer to the element to be raised on the stack. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{stack_8c_a400c152467126af53c8f0634a5161b27}\label{stack_8c_a400c152467126af53c8f0634a5161b27}} 
\index{stack.c@{stack.c}!new\_upper\_element@{new\_upper\_element}}
\index{new\_upper\_element@{new\_upper\_element}!stack.c@{stack.c}}
\doxysubsubsection{\texorpdfstring{new\_upper\_element()}{new\_upper\_element()}}
{\footnotesize\ttfamily static struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}}$\ast$ new\+\_\+upper\+\_\+element (\begin{DoxyParamCaption}\item[{int}]{name,  }\item[{enum \mbox{\hyperlink{all__objects_8h_adc6e5733fc3c22f0a7b2914188c49c90}{state}}}]{state\+\_\+element,  }\item[{void $\ast$}]{location\+\_\+in\+\_\+cache,  }\item[{struct \mbox{\hyperlink{structstack}{stack}}}]{stack,  }\item[{struct \mbox{\hyperlink{structhash}{hash}} $\ast$}]{hash }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Implementation of a part of the algorithm when an element comes to the input that is not written to the stack. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & The name of the input file. \\
\hline
\mbox{\texttt{ in}}  & {\em state\+\_\+element} & The state element to add \\
\hline
\mbox{\texttt{ in}}  & {\em location\+\_\+in\+\_\+cache} & The address where the element is stored in the cache \\
\hline
\mbox{\texttt{ in,out}}  & {\em stack} & The stack structure in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em hash} & The hash table in which changes will occur. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Void $\ast$ pointer to the location in the cache where the incoming file should be written. 
\end{DoxyReturn}
\mbox{\Hypertarget{stack_8c_a4636d873697b1f557367cc40419b7747}\label{stack_8c_a4636d873697b1f557367cc40419b7747}} 
\index{stack.c@{stack.c}!non\_resident\_in\_stack@{non\_resident\_in\_stack}}
\index{non\_resident\_in\_stack@{non\_resident\_in\_stack}!stack.c@{stack.c}}
\doxysubsubsection{\texorpdfstring{non\_resident\_in\_stack()}{non\_resident\_in\_stack()}}
{\footnotesize\ttfamily static void$\ast$ non\+\_\+resident\+\_\+in\+\_\+stack (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structstack}{stack}}}]{stack,  }\item[{struct \mbox{\hyperlink{structlist}{list}}}]{list,  }\item[{struct \mbox{\hyperlink{structhash}{hash}} $\ast$}]{hash,  }\item[{struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$}]{element\+\_\+in\+\_\+stack }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Implementation of a part of the algorithm when an element comes to the input that is written to the stack with the Non\+\_\+resident\+\_\+\+H\+IR status. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em stack} & The stack structure in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em list} & The list structure in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em hash} & The hash table in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em element\+\_\+in\+\_\+stack} & Pointer to the location of the incoming element on the stack. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Void $\ast$ pointer to the location in the cache where the incoming file should be written. 
\end{DoxyReturn}
\mbox{\Hypertarget{stack_8c_a68f60a10327b5f24a24ced2ebf539a11}\label{stack_8c_a68f60a10327b5f24a24ced2ebf539a11}} 
\index{stack.c@{stack.c}!not\_in\_stack@{not\_in\_stack}}
\index{not\_in\_stack@{not\_in\_stack}!stack.c@{stack.c}}
\doxysubsubsection{\texorpdfstring{not\_in\_stack()}{not\_in\_stack()}}
{\footnotesize\ttfamily static void$\ast$ not\+\_\+in\+\_\+stack (\begin{DoxyParamCaption}\item[{int}]{name,  }\item[{int}]{len\+\_\+\+L\+IR,  }\item[{struct \mbox{\hyperlink{structstack}{stack}}}]{stack,  }\item[{struct \mbox{\hyperlink{structlist}{list}}}]{list,  }\item[{struct \mbox{\hyperlink{structhash}{hash}} $\ast$}]{hash,  }\item[{struct \mbox{\hyperlink{structcache__storage__t}{cache\+\_\+storage\+\_\+t}} $\ast$}]{cache }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Implementation of a part of the algorithm when an element comes to the input that is not written to the stack. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & The name of the input file. \\
\hline
\mbox{\texttt{ in}}  & {\em len\+\_\+\+L\+IR} & Length of the L\+IR memory area. \\
\hline
\mbox{\texttt{ in,out}}  & {\em stack} & The stack structure in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em list} & The list structure in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em hash} & The hash table in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em cache} & The cache array where all files are stored. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Void $\ast$ pointer to the location in the cache where the incoming file should be written. 
\end{DoxyReturn}
\mbox{\Hypertarget{stack_8c_afe2bc06c177d97f9c9cba1e0be0f7080}\label{stack_8c_afe2bc06c177d97f9c9cba1e0be0f7080}} 
\index{stack.c@{stack.c}!only\_in\_list@{only\_in\_list}}
\index{only\_in\_list@{only\_in\_list}!stack.c@{stack.c}}
\doxysubsubsection{\texorpdfstring{only\_in\_list()}{only\_in\_list()}}
{\footnotesize\ttfamily static void only\+\_\+in\+\_\+list (\begin{DoxyParamCaption}\item[{int}]{name,  }\item[{struct \mbox{\hyperlink{structstack}{stack}}}]{stack,  }\item[{struct \mbox{\hyperlink{structlist}{list}}}]{list,  }\item[{struct \mbox{\hyperlink{structhash}{hash}} $\ast$}]{hash }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Implementation of a part of the algorithm when an element comes to the input that is written only in the list. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & The name of the input file. \\
\hline
\mbox{\texttt{ in,out}}  & {\em stack} & The stack structure in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em list} & The list structure in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em hash} & The hash table in which changes will occur. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{stack_8c_a05e1a123d3dfcc32ce77fbe3021e4882}\label{stack_8c_a05e1a123d3dfcc32ce77fbe3021e4882}} 
\index{stack.c@{stack.c}!print\_down@{print\_down}}
\index{print\_down@{print\_down}!stack.c@{stack.c}}
\doxysubsubsection{\texorpdfstring{print\_down()}{print\_down()}}
{\footnotesize\ttfamily void print\+\_\+down (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$}]{upper\+\_\+element }\end{DoxyParamCaption})}

Prints to the console the names of the elements in the object from the top of the doubly linked list. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em upper\+\_\+element} & Pointer to the upper element of a doubly linked list. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{stack_8c_abd4c5c60fc300702dbc2da5acb6078ba}\label{stack_8c_abd4c5c60fc300702dbc2da5acb6078ba}} 
\index{stack.c@{stack.c}!print\_up@{print\_up}}
\index{print\_up@{print\_up}!stack.c@{stack.c}}
\doxysubsubsection{\texorpdfstring{print\_up()}{print\_up()}}
{\footnotesize\ttfamily void print\+\_\+up (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$}]{down\+\_\+element }\end{DoxyParamCaption})}

Prints to the console the names of the elements in the object from the bottom of the doubly linked list. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em down\+\_\+element} & Pointer to the down element of a doubly linked list. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{stack_8c_a6d9629de3eb7834af77047c3c184578a}\label{stack_8c_a6d9629de3eb7834af77047c3c184578a}} 
\index{stack.c@{stack.c}!resident\_in\_stack@{resident\_in\_stack}}
\index{resident\_in\_stack@{resident\_in\_stack}!stack.c@{stack.c}}
\doxysubsubsection{\texorpdfstring{resident\_in\_stack()}{resident\_in\_stack()}}
{\footnotesize\ttfamily static void resident\+\_\+in\+\_\+stack (\begin{DoxyParamCaption}\item[{int}]{name,  }\item[{struct \mbox{\hyperlink{structstack}{stack}}}]{stack,  }\item[{struct \mbox{\hyperlink{structlist}{list}}}]{list,  }\item[{struct \mbox{\hyperlink{structhash}{hash}} $\ast$}]{hash,  }\item[{struct \mbox{\hyperlink{structdlinked__list__element}{dlinked\+\_\+list\+\_\+element}} $\ast$}]{element\+\_\+in\+\_\+stack }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Implementation of a part of the algorithm when an element comes to the input that is written to the stack with the Resident\+\_\+\+H\+IR status. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & The name of the input file. \\
\hline
\mbox{\texttt{ in,out}}  & {\em stack} & The stack structure in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em list} & The list structure in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em hash} & The hash table in which changes will occur. \\
\hline
\mbox{\texttt{ in,out}}  & {\em element\+\_\+in\+\_\+stack} & Pointer to the location of the incoming element on the stack. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{stack_8c_a5225b84245d2bb229e73dda3f07e0e2a}\label{stack_8c_a5225b84245d2bb229e73dda3f07e0e2a}} 
\index{stack.c@{stack.c}!to\_non\_resident@{to\_non\_resident}}
\index{to\_non\_resident@{to\_non\_resident}!stack.c@{stack.c}}
\doxysubsubsection{\texorpdfstring{to\_non\_resident()}{to\_non\_resident()}}
{\footnotesize\ttfamily static void to\+\_\+non\+\_\+resident (\begin{DoxyParamCaption}\item[{int}]{name,  }\item[{struct \mbox{\hyperlink{structhash}{hash}} $\ast$}]{hash }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Removes a pointer to stack from the hash of the specified element and changes its status to Non\+\_\+resident\+\_\+\+H\+IR. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em name} & The name of the input file. \\
\hline
\mbox{\texttt{ in,out}}  & {\em hash} & The hash table in which changes will occur. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Void $\ast$ pointer to the location in the cache where the incoming file should be written. N\+U\+LL if the file has already been written. 
\end{DoxyReturn}
